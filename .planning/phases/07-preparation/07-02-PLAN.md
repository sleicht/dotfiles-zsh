---
phase: 07-preparation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/audit-secrets.sh
  - scripts/audit-gitleaks.toml
  - scripts/verify-configs.sh
  - scripts/verify-lib/check-exists.sh
  - scripts/verify-lib/check-valid.sh
  - scripts/verify-lib/check-parsable.sh
  - scripts/verify-checks/.gitkeep
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Running audit-secrets.sh scans ALL config files and produces a categorised findings report"
    - "The audit script can be re-run before each phase to detect new secrets"
    - "Running verify-configs.sh executes any check files in verify-checks/ and produces pass/fail summary"
    - "The verification framework accepts --phase NN to filter checks for a specific phase"
    - "Helper libraries provide reusable check functions (file exists, no template errors, app parsable)"
  artifacts:
    - path: "scripts/audit-secrets.sh"
      provides: "Reusable secret detection with gitleaks + custom patterns"
      min_lines: 60
    - path: "scripts/audit-gitleaks.toml"
      provides: "Custom gitleaks rules for dotfile-specific patterns (emails, user paths, IPs)"
      contains: "user-path"
    - path: "scripts/verify-configs.sh"
      provides: "Plugin-based verification runner"
      min_lines: 40
    - path: "scripts/verify-lib/check-exists.sh"
      provides: "File existence check helper"
    - path: "scripts/verify-lib/check-valid.sh"
      provides: "Template error detection helper"
    - path: "scripts/verify-lib/check-parsable.sh"
      provides: "Application config parsability helper"
  key_links:
    - from: "scripts/audit-secrets.sh"
      to: "gitleaks"
      via: "CLI invocation"
      pattern: "gitleaks detect"
    - from: "scripts/audit-secrets.sh"
      to: "scripts/audit-gitleaks.toml"
      via: "--config flag"
      pattern: "config.*audit-gitleaks"
    - from: "scripts/verify-configs.sh"
      to: "scripts/verify-lib/*.sh"
      via: "source command"
      pattern: "source.*lib/"
    - from: "scripts/verify-configs.sh"
      to: "scripts/verify-checks/*.sh"
      via: "glob iteration"
      pattern: "verify-checks/.*\\.sh"
---

<objective>
Create the reusable secret audit script and extensible verification framework that will gate every future phase migration.

Purpose: PREP-02 requires a secret audit that categorises findings (Bitwarden secret, template variable, safe to ignore). PREP-03 requires a verification runner with plugin architecture so each phase (8-12) can add its own check file. Both tools must be standalone scripts (manual invocation, not chezmoi hooks).

Output: audit-secrets.sh (with custom gitleaks config), verify-configs.sh (runner), verify-lib/ (helpers), verify-checks/ (empty directory ready for Phase 8+).
</objective>

<execution_context>
@/Users/stephanlv_fanaka/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stephanlv_fanaka/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-preparation/07-CONTEXT.md
@.planning/phases/07-preparation/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create secret audit script with custom gitleaks config</name>
  <files>
    scripts/audit-secrets.sh
    scripts/audit-gitleaks.toml
  </files>
  <action>
  Create two files in the dotfiles-zsh repo's scripts/ directory (alongside existing backup-dotfiles.sh, verify-backup.sh, etc.).

  **scripts/audit-gitleaks.toml:**
  Custom gitleaks configuration that extends default rules with dotfile-specific patterns:
  - `user-path-macos`: Detect /Users/[username] paths (portability issue)
  - `user-path-linux`: Detect /home/[username] paths (portability issue)
  - `email-address`: Detect email addresses (PII)
  - `private-ip`: Detect 192.168.x.x and 10.x.x.x private IPs
  - `hostname-pattern`: Detect server hostnames (e.g., hostname = "myserver.example.com")
  - Global allowlist: Exclude .git/, .planning/, LICENSE.md, README.md, *.md files, and the gitleaks config itself
  - Inherit default rules via `[extend] useDefault = true`
  - NOTE: This is a SEPARATE config from the chezmoi source .gitleaks.toml (which handles commit-time scanning). This one is for the audit script scanning the entire repo.

  **scripts/audit-secrets.sh:**
  Bash script following the project's existing script patterns (see scripts/backup-dotfiles.sh for style reference):
  - Shebang: `#!/usr/bin/env bash`
  - `set -euo pipefail`
  - Colour output with GREEN/RED/YELLOW/NC variables
  - SCRIPT_DIR and REPO_ROOT detection

  The script must:
  1. Check gitleaks is installed (exit with helpful message if not)
  2. Run `gitleaks detect --source "$REPO_ROOT" --config "$SCRIPT_DIR/audit-gitleaks.toml" --report-path "$FINDINGS_FILE" --no-git` to scan ALL files (not just git-tracked)
  3. Run custom ripgrep patterns for things gitleaks may miss:
     - Email addresses: `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`
     - User-specific paths: `/Users/[a-zA-Z0-9_-]+` and `/home/[a-zA-Z0-9_-]+`
     - IP addresses: `[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`
     - API key assignments: `api[_-]?key.*[:=]`
     - Token assignments: `token.*[:=]`
     - Password assignments: `password.*[:=]`
  4. Exclude scanning of: .git/, .planning/, LICENSE.md, README.md, *.md, audit-gitleaks.toml, audit-secrets.sh itself, node_modules/, logs/
  5. Generate a Markdown report at `scripts/audit-report-YYYYMMDD-HHMMSS.md` with:
     - Summary table (gitleaks count, custom pattern count, total)
     - Gitleaks findings table: File | Line | Rule | Match (truncated) | Category | Action
     - Custom pattern findings table: File | Line | Pattern | Match (truncated) | Category | Action
     - Category and Action columns pre-filled with "TODO" for manual review
     - Categorisation guide section explaining: Bitwarden Secret, Template Variable, Safe to Ignore
     - Next steps section
  6. Print coloured summary to stdout
  7. Exit code 1 if findings > 0, exit code 0 if clean

  Script must be executable (chmod +x). Use `jq` to parse gitleaks JSON output. Use `rg` (ripgrep) for custom patterns -- both are already installed.

  IMPORTANT: The script scans the dotfiles-zsh repo (REPO_ROOT = git rev-parse --show-toplevel), not the chezmoi source directory. This catches secrets in configs BEFORE they are migrated to chezmoi.
  </action>
  <verify>
  1. `bash -n scripts/audit-secrets.sh` confirms no syntax errors
  2. `./scripts/audit-secrets.sh` runs and produces a report (findings expected -- user paths, emails, etc. likely exist)
  3. Report file exists at scripts/audit-report-*.md with proper table structure
  4. Script exits with code 1 if findings exist (expected for initial run)
  5. Re-running produces a new timestamped report
  </verify>
  <done>
  audit-secrets.sh runs successfully, detects findings in the dotfiles-zsh repo, produces a categorised Markdown report, and can be re-run before each phase. audit-gitleaks.toml extends default gitleaks rules with dotfile-specific patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create plugin-based verification framework</name>
  <files>
    scripts/verify-configs.sh
    scripts/verify-lib/check-exists.sh
    scripts/verify-lib/check-valid.sh
    scripts/verify-lib/check-parsable.sh
    scripts/verify-checks/.gitkeep
  </files>
  <action>
  Create the verification framework in the dotfiles-zsh repo's scripts/ directory.

  **scripts/verify-lib/check-exists.sh:**
  Helper function `check_file_exists` that:
  - Takes a file path as argument
  - Returns 0 if file or directory exists, 1 otherwise
  - Prints nothing (caller handles output)

  **scripts/verify-lib/check-valid.sh:**
  Helper function `check_no_template_errors` that:
  - Takes a file path as argument
  - Checks for unprocessed chezmoi template markers: `{{ }}` (but not in comments or documentation)
  - Checks for TEMPLATE_ERROR placeholder strings
  - Checks for empty files that should not be empty
  - Returns 0 if valid, 1 if template errors detected

  **scripts/verify-lib/check-parsable.sh:**
  Helper function `check_app_can_parse` that:
  - Takes two arguments: app name, config file path
  - Uses case statement to dispatch to app-specific validation:
    - `bat`: `bat --config-file "$config" --list-themes &>/dev/null`
    - `lsd`: `lsd --version &>/dev/null` (no config validation flag)
    - `btop`: Check file starts with comment or valid config syntax
    - `kitty`: `kitty --config "$config" --debug-config &>/dev/null`
    - `wezterm`: Check Lua syntax with `luac -p "$config" 2>/dev/null || wezterm show-config --config-file "$config" &>/dev/null`
    - `lazygit`: `lazygit --print-default-config &>/dev/null` (no per-file validation)
    - `ghostty`: Check config file has valid key=value format
    - `*`: Return 0 (skip unknown apps)
  - Returns 0 if parsable, 1 if not

  **scripts/verify-configs.sh:**
  Main verification runner following project bash script patterns:
  - Shebang: `#!/usr/bin/env bash`
  - `set -euo pipefail`
  - Colour output (GREEN, RED, YELLOW, NC)
  - SCRIPT_DIR detection

  The runner must:
  1. Source all helper libraries from verify-lib/*.sh
  2. Accept `--phase NN` argument to filter checks for a specific phase
  3. Accept `--verbose` flag for detailed output
  4. Iterate over all .sh files in verify-checks/ directory
  5. For each check file:
     - Extract phase number from filename prefix (e.g., "08" from "08-basic-configs.sh")
     - Apply phase filter if --phase specified
     - Source the check file in a subshell to isolate variables
     - Track pass/fail count
  6. Print summary: Total checks, Passed (green), Failed (red)
  7. Exit code 0 if all passed, exit code 1 if any failed
  8. Handle case where no check files exist yet (print informational message, exit 0)

  **scripts/verify-checks/.gitkeep:**
  Empty file to ensure the directory is tracked in git. This directory starts empty -- Phases 8-12 will each add their own check file here (e.g., 08-basic-configs.sh, 09-terminals.sh, etc.).

  All scripts must be executable (chmod +x on .sh files). Follow the same code style as existing scripts/backup-dotfiles.sh.
  </action>
  <verify>
  1. `bash -n scripts/verify-configs.sh` confirms no syntax errors
  2. `bash -n scripts/verify-lib/check-exists.sh` confirms no syntax errors
  3. `bash -n scripts/verify-lib/check-valid.sh` confirms no syntax errors
  4. `bash -n scripts/verify-lib/check-parsable.sh` confirms no syntax errors
  5. `./scripts/verify-configs.sh` runs and reports "No check files found" or "0 checks" (since verify-checks/ is empty)
  6. `./scripts/verify-configs.sh --phase 08` runs without error
  7. All .sh files are executable
  </verify>
  <done>
  Verification runner executes without errors, loads helper libraries, handles empty checks directory gracefully, accepts --phase filter. Framework is ready for Phase 8+ to add check files. Helper libraries provide check_file_exists, check_no_template_errors, and check_app_can_parse functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run initial secret audit and commit all tooling</name>
  <files>
    scripts/audit-secrets.sh
    scripts/audit-gitleaks.toml
    scripts/verify-configs.sh
    scripts/verify-lib/check-exists.sh
    scripts/verify-lib/check-valid.sh
    scripts/verify-lib/check-parsable.sh
    scripts/verify-checks/.gitkeep
    .gitignore
  </files>
  <action>
  1. Run the secret audit script: `./scripts/audit-secrets.sh`
  2. The initial run WILL produce findings (user-specific paths, possible emails, etc. in config files). This is expected.
  3. Review the generated audit report. For each finding, add the category directly in the report:
     - `/Users/stephanlv_fanaka` paths -> "Template Variable" (will be templated during migration)
     - Email addresses in git config -> "Template Variable" (already templated in v1.0.0)
     - API keys or tokens -> "Bitwarden Secret" (will need Bitwarden entries)
     - Example/documentation values -> "Safe to Ignore"
  4. Save the categorised report as `scripts/audit-report-initial.md` (rename from timestamped version for reference)
  5. Add `scripts/audit-report-*.md` to the dotfiles-zsh .gitignore (audit reports should NOT be committed -- they may contain secret excerpts)
  6. Run the verification runner to confirm it works: `./scripts/verify-configs.sh`
  7. Commit all tooling to the dotfiles-zsh repo:
     ```bash
     git add scripts/audit-secrets.sh scripts/audit-gitleaks.toml \
             scripts/verify-configs.sh scripts/verify-lib/ scripts/verify-checks/.gitkeep \
             .gitignore
     git commit -m "feat(07-02): add secret audit and verification framework"
     ```

  NOTE: Do NOT commit audit-report-*.md files -- they are gitignored because they may contain excerpts of detected secrets.
  </action>
  <verify>
  1. Initial audit report exists and has categorised findings
  2. `scripts/audit-report-*.md` is in .gitignore
  3. `./scripts/verify-configs.sh` exits 0 (no checks to fail)
  4. All tooling files are committed to git
  5. `git status` shows clean working tree (excluding audit reports)
  </verify>
  <done>
  PREP-02 satisfied: Secret audit script scans all configs and produces categorised findings. PREP-03 satisfied: Verification framework is operational and extensible. Initial audit report documents the current state of secrets in the repo. All tooling committed.
  </done>
</task>

</tasks>

<verification>
1. `./scripts/audit-secrets.sh` runs and produces categorised Markdown report
2. `./scripts/verify-configs.sh` runs and handles empty checks directory
3. `./scripts/verify-configs.sh --phase 08` accepts phase filter without error
4. Helper libraries source without errors: `source scripts/verify-lib/check-exists.sh && check_file_exists /tmp`
5. audit-gitleaks.toml has custom rules for user-path, email, IP patterns
6. All scripts are executable and pass `bash -n` syntax check
7. Audit reports are gitignored
</verification>

<success_criteria>
- PREP-02 satisfied: Reusable secret audit scans all configs, categorises findings, can gate future phase migrations
- PREP-03 satisfied: Plugin-based verification runner loads checks from directory, helpers provide existence/validity/parsability checks
- Both scripts follow the project's existing bash scripting patterns
- All tooling committed to dotfiles-zsh repo
</success_criteria>

<output>
After completion, create `.planning/phases/07-preparation/07-02-SUMMARY.md`
</output>
