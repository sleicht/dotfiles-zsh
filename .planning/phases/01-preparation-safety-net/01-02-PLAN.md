---
phase: 01-preparation-safety-net
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/restore-dotfiles.sh
  - scripts/verify-backup.sh
autonomous: true

must_haves:
  truths:
    - "Recovery script shows files before restoring and asks for confirmation"
    - "User can skip individual categories during recovery"
    - "Recovery script exits cleanly if backup not found"
    - "Verification script reports missing critical files"
  artifacts:
    - path: "scripts/restore-dotfiles.sh"
      provides: "Interactive category-based recovery"
      min_lines: 60
    - path: "scripts/verify-backup.sh"
      provides: "Backup completeness validation"
      min_lines: 40
  key_links:
    - from: "scripts/restore-dotfiles.sh"
      to: "/Volumes/PortableSSD/home_backup/dotfiles-backup"
      via: "rsync restore"
      pattern: "rsync.*BACKUP_DIR"
    - from: "scripts/verify-backup.sh"
      to: "backup-metadata.txt"
      via: "metadata check"
      pattern: "backup-metadata"
---

<objective>
Create recovery and verification infrastructure: interactive restore script with category-based selection, and verification script to validate backup completeness.

Purpose: Enable fast recovery (< 2 minutes target) and confidence that backups are complete before starting migration. Interactive recovery prevents accidental overwrites.

Output: Two scripts that together provide restore capability and backup validation.
</objective>

<execution_context>
@/Users/stephanlv_fanaka/.claude/get-shit-done/workflows/execute-plan.md
@/Users/stephanlv_fanaka/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-preparation-safety-net/01-CONTEXT.md
@.planning/phases/01-preparation-safety-net/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interactive recovery script</name>
  <files>scripts/restore-dotfiles.sh</files>
  <action>
Create bash script implementing Pattern 3 from RESEARCH.md (interactive recovery with granularity):

**Structure:**
```bash
#!/usr/bin/env bash
set -euo pipefail
```

**Configuration:**
- `BACKUP_DRIVE="${BACKUP_DRIVE:-/Volumes/PortableSSD/home_backup}"`
- `BACKUP_DIR="$BACKUP_DRIVE/dotfiles-backup"`

**Backup existence check:**
- Verify `$BACKUP_DIR` exists
- If not, print error: "Backup not found at $BACKUP_DIR"
- Suggest: check drive is mounted, verify backup was created
- Exit 1

**Core restore function (from research):**
```bash
restore_category() {
  local category=$1
  local source_path=$2
  local dest_path=$3

  echo ""
  echo "=== $category ==="

  # Check if source exists in backup
  if [ ! -e "$BACKUP_DIR/$source_path" ]; then
    echo "Not found in backup: $source_path (skipping)"
    return 0
  fi

  # Show files that would be restored
  echo "Files to restore:"
  find "$BACKUP_DIR/$source_path" -type f 2>/dev/null | head -10
  local count=$(find "$BACKUP_DIR/$source_path" -type f 2>/dev/null | wc -l)
  echo "... ($count files total)"

  # Interactive prompt with yes/no/skip
  while true; do
    read -p "Restore $category? (yes/no/skip) " response
    case $response in
      yes)
        rsync -av "$BACKUP_DIR/$source_path" "$dest_path"
        echo "Restored $category"
        return 0
        ;;
      no)
        echo "Aborting recovery"
        exit 0
        ;;
      skip)
        echo "Skipped $category"
        return 0
        ;;
      *)
        echo "Please enter: yes, no, or skip"
        ;;
    esac
  done
}
```

**Define restore categories:**
Categories must match what users actually care about recovering:
1. Shell configs: `.zshrc`, `.zshenv`, `.zprofile`, `zsh.d/`
2. Git configs: `.config/git/`, `.gitconfig`
3. Editor configs: `.config/nvim/`, `.vimrc`
4. Tool configs: `.config/mise/`, `.config/sheldon/`, `.config/atuin/`
5. Terminal configs: `.config/ghostty/`, `.config/kitty/`, `.config/wezterm.lua`
6. Dotfiles repo: `.dotfiles/`
7. All remaining dotfiles: `.*` (catch-all)

**Recovery execution:**
- Print banner: "DOTFILES RECOVERY"
- Show backup metadata if exists (timestamp, machine)
- Warn: "This will overwrite existing files. Proceed with caution."
- Call restore_category for each category in order
- Print completion message with suggestion to test shell: `exec zsh`

**No automatic shell verification:**
Per CONTEXT.md, post-restore just restores files. User manually tests shell.
  </action>
  <verify>
Script passes syntax check and contains interactive prompts:
```bash
chmod +x scripts/restore-dotfiles.sh && \
bash -n scripts/restore-dotfiles.sh && \
grep -q 'restore_category' scripts/restore-dotfiles.sh && \
grep -q 'yes/no/skip\|yes.*no.*skip' scripts/restore-dotfiles.sh
```
  </verify>
  <done>Recovery script provides category-based interactive restore with confirmation prompts</done>
</task>

<task type="auto">
  <name>Task 2: Create backup verification script</name>
  <files>scripts/verify-backup.sh</files>
  <action>
Create verification script to validate backup completeness:

**Structure:**
```bash
#!/usr/bin/env bash
set -euo pipefail
```

**Configuration:**
- `BACKUP_DRIVE="${BACKUP_DRIVE:-/Volumes/PortableSSD/home_backup}"`
- `BACKUP_DIR="$BACKUP_DRIVE/dotfiles-backup"`

**Verification checks:**

1. **Backup existence:**
   - Check `$BACKUP_DIR` exists
   - Check `backup-metadata.txt` exists

2. **Metadata validation:**
   - Read and display backup timestamp from metadata
   - Warn if backup is older than 7 days

3. **Critical files presence:**
   Define list of critical dotfiles that MUST exist in backup:
   ```bash
   CRITICAL_FILES=(
     ".zshrc"
     ".zshenv"
     ".zprofile"
     ".config/git/config"
     ".config/sheldon/plugins.toml"
     ".dotfiles"  # or wherever the repo lives
   )
   ```
   - For each, check existence in backup
   - Track missing count

4. **Directory structure validation:**
   - Check key directories exist: `.config/`, `zsh.d/`
   - Report file counts per directory

5. **Symlinks resolved check:**
   - Verify `_symlinks_resolved/` directory exists
   - Count dereferenced symlinks

6. **Summary report:**
   - Print: "Backup verification complete"
   - Print: "Critical files: X/Y present"
   - Print: "Last backup: [timestamp]"
   - Print: "Total files: [count]"
   - Exit 0 if all critical files present, exit 1 if any missing

**Output format:**
Human-readable report suitable for visual inspection before starting migration.
  </action>
  <verify>
Script validates correctly:
```bash
chmod +x scripts/verify-backup.sh && \
bash -n scripts/verify-backup.sh && \
grep -q 'CRITICAL_FILES' scripts/verify-backup.sh && \
grep -q 'backup-metadata' scripts/verify-backup.sh
```
  </verify>
  <done>Verification script checks critical files, metadata, and provides summary report</done>
</task>

</tasks>

<verification>
Run syntax checks on both scripts:
```bash
bash -n scripts/restore-dotfiles.sh
bash -n scripts/verify-backup.sh

# Verify scripts are executable
ls -la scripts/*.sh
```
</verification>

<success_criteria>
1. `scripts/restore-dotfiles.sh` exists and passes syntax check
2. Recovery script has category-based restore with interactive prompts
3. Recovery script handles missing backup gracefully
4. `scripts/verify-backup.sh` exists and passes syntax check
5. Verification script checks for critical dotfiles presence
6. Verification script reads and validates backup metadata
</success_criteria>

<output>
After completion, create `.planning/phases/01-preparation-safety-net/01-02-SUMMARY.md`
</output>
